<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>cautas - 予定を入れるだけ。あとは全部、繋がる。</title>
  <link rel="stylesheet" href="css/style.css">
</head>
<body>
  <canvas id="three-canvas"></canvas>

  <div class="scroll-container">
    <section class="hero">
      <div class="hero-character">
        <img src="public/images/characters/rabbit-animated.gif" alt="白うさぎ">
      </div>
      <div class="hero-catchphrase">
        <h1>予定を入れるだけ。<br>あとは全部、繋がる。</h1>
      </div>
    </section>
  </div>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.5/gsap.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.5/ScrollTrigger.min.js"></script>

  <script>
    gsap.registerPlugin(ScrollTrigger);

    (function initThreeJS() {
      const canvas = document.getElementById('three-canvas');
      const scene = new THREE.Scene();

      const camera = new THREE.PerspectiveCamera(
        60,
        window.innerWidth / window.innerHeight,
        0.1,
        1000
      );
      camera.position.set(0, 0, 30);
      camera.lookAt(0, 0, 0);

      const renderer = new THREE.WebGLRenderer({
        canvas: canvas,
        antialias: true,
        alpha: false
      });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
      renderer.toneMapping = THREE.ACESFilmicToneMapping;
      renderer.toneMappingExposure = 1.2;

      const bgColors = {
        start: new THREE.Color(0x1a1a1a),
        end: new THREE.Color(0xFDFCFA)
      };
      scene.background = bgColors.start.clone();

      // ライティング
      scene.add(new THREE.AmbientLight(0xffffff, 0.9));
      
      const dirLight = new THREE.DirectionalLight(0xffffff, 0.7);
      dirLight.position.set(5, 10, 10);
      scene.add(dirLight);

      const pointLight1 = new THREE.PointLight(0x58CC02, 1.5, 50);
      pointLight1.position.set(-8, 5, -10);
      scene.add(pointLight1);

      const pointLight2 = new THREE.PointLight(0xFF9500, 1.5, 50);
      pointLight2.position.set(8, -3, -10);
      scene.add(pointLight2);

      const pointLight3 = new THREE.PointLight(0xFF6B9D, 1.2, 50);
      pointLight3.position.set(0, 8, -5);
      scene.add(pointLight3);

      const gltfLoader = new THREE.GLTFLoader();

      // ===== 背景アイコン（12個）- ランダム配置 =====
      const bgIcons = [];
      const bgIconData = [
        { path: 'public/images/icons/book.glb', x: -20, y: 12, z: -10 },
        { path: 'public/images/icons/heart.glb', x: 22, y: -8, z: -8 },
        { path: 'public/images/icons/key.glb', x: -15, y: -14, z: -12 },
        { path: 'public/images/icons/map.glb', x: 18, y: 10, z: -15 },
        { path: 'public/images/icons/mobile.glb', x: -25, y: 0, z: -5 },
        { path: 'public/images/icons/video.glb', x: 25, y: 5, z: -10 },
        { path: 'public/images/icons/computer.glb', x: -10, y: 18, z: -8 },
        { path: 'public/images/icons/copy.glb', x: 12, y: -16, z: -12 },
        { path: 'public/images/icons/at.glb', x: -22, y: -10, z: -6 },
        { path: 'public/images/icons/lock.glb', x: 0, y: 15, z: -10 },
        { path: 'public/images/icons/chat2.glb', x: -8, y: -18, z: -8 },
        { path: 'public/images/icons/boy.glb', x: 20, y: -2, z: -14 }
      ];

      bgIconData.forEach(item => {
        gltfLoader.load(item.path, gltf => {
          const model = gltf.scene;
          model.position.set(item.x, item.y, item.z);
          model.scale.set(1.5, 1.5, 1.5);
          // 正面を向かせる（カメラ方向）
          model.lookAt(camera.position);
          model.userData = {
            basePos: new THREE.Vector3(item.x, item.y, item.z),
            driftSpeed: { 
              x: 0.3 + Math.random() * 0.2, 
              y: 0.4 + Math.random() * 0.2, 
              z: 0.2 + Math.random() * 0.2 
            },
            driftOffset: { 
              x: Math.random() * Math.PI * 2, 
              y: Math.random() * Math.PI * 2, 
              z: Math.random() * Math.PI * 2 
            },
            driftRange: { x: 2, y: 1.5, z: 1 }
          };
          scene.add(model);
          bgIcons.push(model);
        }, undefined, err => console.log('背景アイコン読み込みエラー:', item.path));
      });

      // ===== メインアイコン（8個）- 背後から入ってくる =====
      const mainIcons = [];
      const mainIconData = [
        { path: 'public/images/icons/calender.glb', entry: { x: 10, y: 5 } },
        { path: 'public/images/icons/calculator.glb', entry: { x: -12, y: -3 } },
        { path: 'public/images/icons/chart.glb', entry: { x: -8, y: 8 } },
        { path: 'public/images/icons/chat.glb', entry: { x: 11, y: -6 } },
        { path: 'public/images/icons/clock.glb', entry: { x: 0, y: 10 } },
        { path: 'public/images/icons/folder.glb', entry: { x: -10, y: 0 } },
        { path: 'public/images/icons/mic.glb', entry: { x: 9, y: -8 } },
        { path: 'public/images/icons/pencil.glb', entry: { x: -5, y: -9 } }
      ];

      // メインアイコンの最終位置をランダムに設定
      const mainEndPositions = [
        { x: -18, y: 8, z: -25 },
        { x: 15, y: -10, z: -30 },
        { x: -12, y: -8, z: -22 },
        { x: 20, y: 5, z: -28 },
        { x: -5, y: 12, z: -35 },
        { x: 8, y: -15, z: -20 },
        { x: -20, y: -5, z: -32 },
        { x: 12, y: 10, z: -26 }
      ];

      mainIconData.forEach((item, index) => {
        gltfLoader.load(item.path, gltf => {
          const model = gltf.scene;
          const entry = item.entry;

          const startX = entry.x * 2;
          const startY = entry.y * 2;
          const startZ = 50;

          const passX = entry.x * 0.8;
          const passY = entry.y * 0.8;
          const passZ = 25;

          // ランダムな最終位置
          const endPos = mainEndPositions[index];

          model.position.set(startX, startY, startZ);
          model.scale.set(0, 0, 0);
          model.visible = false;

          model.userData = {
            startPos: new THREE.Vector3(startX, startY, startZ),
            passPos: new THREE.Vector3(passX, passY, passZ),
            endPos: new THREE.Vector3(endPos.x, endPos.y, endPos.z),
            appearAt: 0.05 + index * 0.08,
            index: index
          };

          scene.add(model);
          mainIcons.push(model);
        }, undefined, err => console.log('メインアイコン読み込みエラー:', item.path));
      });

      let scrollProgress = { value: 0 };

      ScrollTrigger.create({
        trigger: ".scroll-container",
        start: "top top",
        end: "bottom bottom",
        scrub: true,
        onUpdate: (self) => {
          scrollProgress.value = self.progress;
        }
      });

      function animate() {
        requestAnimationFrame(animate);

        const time = Date.now() * 0.001;
        const progress = scrollProgress.value;

        scene.background.lerpColors(bgColors.start, bgColors.end, progress);

        // ===== 背景アイコンの動き =====
        bgIcons.forEach(model => {
          const ud = model.userData;
          
          if (progress < 0.7) {
            model.visible = true;
            
            const driftX = Math.sin(time * ud.driftSpeed.x + ud.driftOffset.x) * ud.driftRange.x;
            const driftY = Math.cos(time * ud.driftSpeed.y + ud.driftOffset.y) * ud.driftRange.y;
            const driftZ = Math.sin(time * ud.driftSpeed.z + ud.driftOffset.z) * ud.driftRange.z;
            
            model.position.set(
              ud.basePos.x + driftX,
              ud.basePos.y + driftY,
              ud.basePos.z + driftZ
            );
            
            // 常にカメラの方を向く（正面が見える）
            model.lookAt(camera.position);
            model.scale.set(1.5, 1.5, 1.5);
            
          } else if (progress < 0.9) {
            model.visible = true;
            const absorpProgress = (progress - 0.7) / 0.2;
            
            const targetX = ud.basePos.x * (1 - absorpProgress);
            const targetY = ud.basePos.y * (1 - absorpProgress);
            const targetZ = ud.basePos.z * (1 - absorpProgress * 0.5);
            
            model.position.set(targetX, targetY, targetZ);
            model.lookAt(camera.position);
            
            const scale = 1.5 * (1 - absorpProgress);
            model.scale.set(Math.max(0.01, scale), Math.max(0.01, scale), Math.max(0.01, scale));
            
          } else {
            model.visible = false;
          }
        });

        // ===== メインアイコンの動き =====
        mainIcons.forEach(model => {
          const appearAt = model.userData.appearAt;
          const duration = 0.15;
          const idx = model.userData.index;

          if (progress < appearAt) {
            model.visible = false;
            model.scale.set(0, 0, 0);

          } else if (progress < appearAt + duration) {
            // Phase 1: 背後から入ってきてカメラ横を通過
            model.visible = true;
            const phaseProgress = (progress - appearAt) / duration;

            const currentPos = new THREE.Vector3().lerpVectors(
              model.userData.startPos,
              model.userData.passPos,
              phaseProgress
            );
            model.position.copy(currentPos);
            
            // 常にカメラの方を向く
            model.lookAt(camera.position);

            const scale = phaseProgress * 3;
            model.scale.set(scale, scale, scale);

          } else if (progress < 0.7) {
            // Phase 2: 奥へ漂っていく（正面を向いたまま）
            model.visible = true;
            const phaseStart = appearAt + duration;
            const phaseProgress = (progress - phaseStart) / (0.7 - phaseStart);

            const basePos = new THREE.Vector3().lerpVectors(
              model.userData.passPos,
              model.userData.endPos,
              Math.min(1, phaseProgress)
            );

            const driftX = Math.sin(time * 0.2 + idx * 2) * 1.5;
            const driftY = Math.cos(time * 0.25 + idx * 1.5) * 1.2;
            const driftZ = Math.sin(time * 0.15 + idx * 2.5) * 0.8;

            model.position.set(
              basePos.x + driftX,
              basePos.y + driftY,
              basePos.z + driftZ
            );
            
            // 常にカメラの方を向く（何のアイコンか分かる）
            model.lookAt(camera.position);

            const scale = 3 - phaseProgress * 1.5;
            model.scale.set(scale, scale, scale);

          } else if (progress < 0.9) {
            // Phase 3: 中心に吸収されて消える（奥の方で）
            model.visible = true;
            const absorpProgress = (progress - 0.7) / 0.2;

            // 中心（0,0）に向かって移動、Zはそのまま奥
            const currentX = model.position.x * (1 - absorpProgress * 0.8);
            const currentY = model.position.y * (1 - absorpProgress * 0.8);
            const currentZ = model.position.z - absorpProgress * 5; // 奥へ

            model.position.set(currentX, currentY, currentZ);
            model.lookAt(camera.position);

            const scale = 1.5 * (1 - absorpProgress);
            model.scale.set(Math.max(0.01, scale), Math.max(0.01, scale), Math.max(0.01, scale));

          } else {
            model.visible = false;
            model.scale.set(0, 0, 0);
          }
        });

        renderer.render(scene, camera);
      }

      animate();

      window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      });
    })();

    // ===== キャラクター & キャッチコピー =====
    const character = document.querySelector('.hero-character');
    const catchphrase = document.querySelector('.hero-catchphrase');

    gsap.set(character, {
      scale: 2.5,
      opacity: 0,
      y: 800,
      zIndex: 100
    });

    gsap.set(catchphrase, {
      opacity: 0,
      y: 50,
      scale: 0.9
    });

    ScrollTrigger.create({
      trigger: ".scroll-container",
      start: "top top",
      end: "bottom bottom",
      pin: ".hero",
      pinSpacing: false
    });

    const mainTL = gsap.timeline({
      scrollTrigger: {
        trigger: '.scroll-container',
        start: 'top top',
        end: 'bottom bottom',
        scrub: true
      }
    });

    mainTL
      .to(character, { y: 250, opacity: 1, scale: 1.5, duration: 0.1, ease: 'power3.out' }, 0.70)
      .to(character, { y: 200, scale: 1.2, duration: 0.08, ease: 'power2.out' }, 0.90)
      .to(catchphrase, { opacity: 1, y: -450, scale: 1, duration: 0.08, ease: 'power2.out' }, 0.88);

    let resizeTimeout;
    window.addEventListener('resize', () => {
      clearTimeout(resizeTimeout);
      resizeTimeout = setTimeout(() => {
        ScrollTrigger.refresh();
      }, 250);
    });
  </script>
</body>
</html>
